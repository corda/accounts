package freighter.testing

import com.r3.corda.lib.accounts.workflows.flows.AccountInfoByUUID
import com.r3.corda.lib.accounts.workflows.flows.CordappVersionDetector
import com.r3.corda.lib.accounts.workflows.flows.CreateAccount
import freighter.deployments.DeploymentContext
import freighter.deployments.NodeBuilder
import freighter.deployments.SingleNodeDeployment
import freighter.machine.DeploymentMachineProvider
import freighter.machine.generateRandomString
import net.corda.core.messaging.startFlow
import net.corda.core.utilities.getOrThrow
import org.hamcrest.MatcherAssert
import org.hamcrest.Matchers.`is`
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import utility.getOrThrow
import java.util.concurrent.CompletableFuture

class AccountsUpgradeDBCompatibility : DockerRemoteMachineBasedTest() {

    val accountsV1Contracts =
        NodeBuilder.DeployedCordapp.fromGradleArtifact(
            group = "com.r3.corda.lib.accounts",
            artifact = "accounts-contracts",
            version = "1.0"
        )

    val accountsV1Workflows =
        NodeBuilder.DeployedCordapp.fromGradleArtifact(
            group = "com.r3.corda.lib.accounts",
            artifact = "accounts-workflows",
            version = "1.0"
        )

    val accountsCurrentWorkflows =
        NodeBuilder.DeployedCordapp.fromClassPath("accounts-workflows")

    val modernCiV1 = NodeBuilder.DeployedCordapp.fromGradleArtifact(
        group = "com.r3.corda.lib.ci",
        artifact = "ci-workflows",
        version = "1.0"
    )
    val stressTesterCordapp = NodeBuilder.DeployedCordapp.fromClassPath("freighter-cordapp-flows")

    lateinit var nms: CompletableFuture<DeploymentMachineProvider.NetworkServicesInfo>

    @BeforeEach
    fun setupNMS() {
        nms = machineProvider.generateNMSEnvironment()
    }

    @Test
    fun `upgrade to current does not break postgres 9_6`() {
        runAccountsOnNodeRunningDatabase(DeploymentMachineProvider.DatabaseType.PG_9_6)
    }

    @Test
    fun `upgrade to current does not break postgres 10_10`() {
        runAccountsOnNodeRunningDatabase(DeploymentMachineProvider.DatabaseType.PG_10_10)
    }

    @Test
    fun `upgrade to current does not break postgres 11_5`() {
        runAccountsOnNodeRunningDatabase(DeploymentMachineProvider.DatabaseType.PG_11_5)
    }

    private fun runAccountsOnNodeRunningDatabase(db: DeploymentMachineProvider.DatabaseType) {
        val randomString = generateRandomString()

        val userName = System.getenv("ARTIFACTORY_USERNAME")
            ?: throw IllegalStateException("Please ensure that ARTIFACTORY_USERNAME is defined in the environment")
        val password = System.getenv("ARTIFACTORY_PASSWORD")
            ?: throw IllegalStateException("Please ensure that ARTIFACTORY_PASSWORD is defined in the environment")

        val deploymentContext = DeploymentContext(machineProvider, nms, userName, password)

        val deploymentResult = SingleNodeDeployment(
            NodeBuilder().withX500("O=PartyB, C=GB, L=LONDON, CN=$randomString")
                .withCordapp(stressTesterCordapp)
                .withCordapp(accountsV1Contracts)
                .withCordapp(accountsV1Workflows)
                .withCordapp(modernCiV1)
                .withDatabase(machineProvider.requestDatabase(db))
        ).withVersion("4.3")
            .deploy(deploymentContext)

        val nodeMachine = deploymentResult.getOrThrow().nodeMachines.single()

        val issuedAccountBeforeUpgrade = nodeMachine.rpc {
            startFlow(
                ::CreateAccount,
                "testAccount"
            ).returnValue.getOrThrow()
        }

        nodeMachine.stopNode()
        nodeMachine.upgradeCordapp(accountsV1Workflows, accountsCurrentWorkflows)
        nodeMachine.startNode()

        val cordappVersionAfterUpgrade = nodeMachine.rpc {
            startFlow(
                ::CordappVersionDetector
            ).returnValue.getOrThrow()
        }

        MatcherAssert.assertThat(cordappVersionAfterUpgrade, `is`("2"))

        val retrievedAfterUpgrade = nodeMachine.rpc {
            startFlow(
                ::AccountInfoByUUID,
                issuedAccountBeforeUpgrade.state.data.identifier.id
            ).returnValue.getOrThrow()
        }
        MatcherAssert.assertThat(issuedAccountBeforeUpgrade.state.data, `is`(retrievedAfterUpgrade?.state?.data))
    }

}